
the top half of the provider class is the
same for dynamic vs dllimport.  use a partial
class and share it?

new sn key for lib.e_sqlcipher.  hmmm.
should we just use the same one as before?
and why do we have the same key for 
the android and ios versions of this?
same goes for e_sqlite3.

--

core had:
	raw
	intptrs
	isqlite3
	bait
	assemblyinfo

providers had:
	util.cs
	pinvoke_whatever
	assemblyinfo

consider keeping the dllimport versions
around as well?  but then do we need separate
provider assemblies again?

seems silly to keep dllimport versions around
just for the search path feature.

UWP WACK will barf on dllimports that are
wrong, right?

runtimeconfig.dev.json
	AdditionalProbingingPath

LoadLibrary vs LoadLibraryEx

bundles:
	green
	e_sqlite3
	e_sqlcipher
	zetetic
	winsqlite3

figure out plats
	ios
	macos
	win
	android
	linux
	other?

in general, only one of the following is true:
	win, LoadLibrary, dll suffix
	everything else, dlopen
		macos, dylib suffix
		everything else, so suffix

Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().Location) -- netstandard 2.0
appdomain.currentdomain.basedirectory -- not in netcore
assembly.codebase -- netstandard 1.5
current working directory -- netstandard 1.3

ios: either system or internal

android: std places
	just load e_sqlite3?

.net core: should find from rid, just
load "e_sqlite3" ?

mono on mac
Xamarin.Mac
mono on linux
.net framework on windows
    subdirs from the targets file

cdecl vs stdcall?

maybe everything which needs a targets file should
also need to pass more info (a path) to Setup

--

add sqlite3_key et al to the pinvoke list?

have setup return the one that was used

string passed to LoadLibrary/dlopen
dlopen vs loadlib

constructing the string:
	basename
		e_sqlite3
		e_sqlcipher
		sqlite3
		sqlcipher
	add dll/dylib/so
	path
		starting
			cwd
			executingassembly.location
			other?
		subdir
			nothing?
			native/rid (targets)

perhaps just autogen a big list of permutations to try.
and then a loop that tries them.

use runtime platform info to reduce the size of the list.

or gen the list at runtime, using runtime platform info
to only gen the ones that make sense.  allows a custom
basename more easily.  gen_permutations_for().

--

run gen_build.cs under dotnet core

the nuspec/targets files should be committed
to the repo

consider default enable_next_stmt() to false

review the weird stuff agg functions do
with the context pointer

consider:  chg inclusion of assemblies in
nuspec such that it errors if the expected
assemblies are not there?  currently, if the
nuspec files are generated when the mt dir
is not built, there are no errors, and pack
will build empty packages.

in setup, check the current OS somehow so
that some checks (like LoadLibrary on non-Windows)
can be skipped.

default load, so the setup call can be optional
in many or most cases

maybe the Setup calls should return the sqlite
version et al?

chg release notes in nuspec to reference a URL

what are the empty dep groups for?

maybe don't do bundle_winsqlite3?  it's kind of
silly.  it doesn't actually bundle anything.  it
just calls (something like) Setup.Load_winsqlite3().

what is batteries_v2.sqlite3 for?

maybe batteries now are per-bundle.  one
function that figures out at runtime what
to load.  for green, it would need to check
to see if it's on iOS.

will bundle_green have a problem because
lib.e_sqlite3 is all one package?  so now
the e_sqlite3 build for iOS is included,
and we just have to have to require it not
to be used?

not sure we need bundle_green at all.

chg cb build scripts to use VS 2017, partly
so we can get arm64 on uwp

later: rename sqlcipher in cb to e_sqlcipher

test on uwp

restore those win32 set directory calls somewhere

preload from arch directory stuff.  subdirectory
by cpu arch.

--

deal with stdcall/winsqlite3 in Setup

need to setup some x86 stdcall builds for testing?
or just use winsqlite3 itself.  irritating that 
the test suite passes using winsqlite3 and either 
calling convention.  why?

DI for the utf8 stuff?  #202

more xunit test cases

goal is to have no ifdefs in core

chg to SourceGear name?

instead of delegate-ish types in raw.cs should the functions
take something like Func<whatever> ?

