
get the word 'static' into the embedded lib name for ios,
so we can add dynamic later

combine net45 libs into one pkg?

config_esqlite3 should get reworked, because it only
generates a nuspec

fix all the native libs to have e_ underscore

use_provider_bait should be renamed.  maybe the whole
use_provider_* stuff should go away.

do we need a copy of the main raw assembly compiled specifically
for every tfm?  like android?  or is it sufficient to have
it compiled for each set of compile options, and each platform
use the one that is compatible with it.

main assembly
	net35
	some basic pcl profile
	netstandard1.0
	netstandard1.1

plugins
	sqlite3
	e_sqlite3
	custom_sqlite3
	sqlcipher
	__Internal

native
	e_sqlite3
	sqlcipher

bundle
	green

need to go to nuget.org and mark some of the older 
packages deprecated

e_sqlite3
custom_sqlite3
default_sqlite3
xamarin_sqlite3 ?

maybe the "first pinvoke set that works" code should
go somewhere else, higher up?

if we're going to build plugins containing a
pinvoke set, we need the corresponding build
of the main assembly to NOT contain that
pinvoke set.

we moved toward auto-init in the main assembly
because when the assembly is referenced in
PCL code only, the Init call still has to go
somewhere.  it would be nice to be able to
write a wrapper (like sqlite-net) which does init
for its consumers, without needing an init call
in each platform-specific project, but if that
wrapper is a PCL, things are harder.

net45
	seems fine
iOS
	only "sqlite3" works, unless dylibs
	__Internal can't be there because linker
android
	"sqlite3" should be removed for Android N
	but that'll break things now (cblite too)
UWP 10
	winsqlite3 should be added
	plain sqlite3 is the extension SDK
UWP 8
	nothing should be there for Certification Kit
.NET Native
	not sure what'll happen here
wp80
	cppinterop

core problem with uwp is that we can't have multiple
sets of pinvokes, so the set we want has to be somewhere,
and we just removed all the "plugins" and left only the
"native" stuff.

in fact, since "sqlite3" cannot be in the main assembly
for UWP 8.1, we need a "sqlite3" plugin, which we have
never needed before.

config_plugin has a problem with the way it uses "what"
and "imp".  what is always "sqlite3" or "sqlcipher",
but now we need the names to be more flexible, since we
can have "sqlite3" with "e" and "sqlite3" without.
it would be better if the current set had "e" in the
name, but they don't.

what if the main assembly never has an implementation
of IProvider in it?  it doesn't even need to be a bait
and switch PCL anymore.  although the platforms still
need to inject an implementation.  provider_bait() would
become useless?

should main nupkg have a wp8-only dep on
native.v120_wp80 ?  argument against this is that
the dep is in bundle_green, and without the dep,
somebody could replace esqlite3.

currently wp8-SL support is limited to esqlite3.  no
sqlcipher.  no extension SDK.  although we could in
theory build multiple versions of this, each linked
against a different library name.

changes to eliminate code in bundle_green and let the main assembly
have multiple pinvokes in it.

win81 failing validation.  C++ compile settings changed since
0.8.6?  Windows App Certification Kit.  is it scanning for
pinvokes?

build iOS targetted for older iOS versions

LoadLibraryEx

--------

use reflection to find all classes that implement ISQLiteProvider?
would this catch the _internal case for ios?

can we do a dylib ios version?

is there any case where we would need the Batteries.Init()
function?  like for an ios problem?

keep Batteries.Init() somewhere, so SQLite-net won't break?

version numbers on SQLitePCL.custom stuff should
not need to match SQLitePCL.raw, and might want to
match the underlying SQLite version number.

maybe a SQLitePCL.custom.sqlite3.nupkg which does
nothing but have platform-specific dependencies
on the others?

need the sqlcipher builds for windows-ish things

and an ios one that uses common crypto

need custom sqlite3 packages in nuget 3.x style

does the native code stuff in nuget 3.x get this
specific?  can we provide a package which just looks
at the environment and then has a dependency on
The Right One?

xamarin.mac shouldn't even need to be built on the Mac.
just use a compatible build of SQLitePCL.raw.dll

do we need two sets of sqlite3 projects?  one set for
e, and the other set for the SL cppinterop stuff?

cppinterop is only for SL-flavored WP8.  it does not
support e.  or it only supports e.

all the custom sqlite builds need to end up called
esqlite3.  except maybe the ones for SL-flavored WP8?

need a dylib build for ios

need e nuget packages

----

clean out the rest of this file

----

Do the collation hook fix thing for config_log

consider whether maybe the sqlite3 intptr dispose should check
the version number and call sqlite3_close_v2 when it's supposedly
available.

switch to xUnit?

switch my env keywords to be the same as the ones nuget uses?

test_cases.cs nuget, nunit vs mstest

add visual studio 2013 c++ runtime sdkreference.  but injecting an
SDKReference in the .targets file sort of doesn't work, and using
a powershell tool is so inelegant.  MESSAGE.

annoying that an injected reference doesn't show up in the
References list in visual studio

error if configuration is not release or debug
but configuration in xamarin.ios is actually stuff like iPhone, etc

why does the sqlitepcl ios platform assembly show
no assembly info when viewed in xamarin studio?

Win32 in the sln file

auto-generate the test projects as well?

docs: need a complete list, in tabular form, of the platform
assemblies and an explanation of the use cases for each one.
auto-generate this.

need at least one test project for each platform assembly.  

add an NUnit project on Windows/Net45, so that build breakage
with NUnit can be detected when making changes on windows.
should reference NUnit as a nuget package

sqlite3.Mac?  or use platform-installed sqlite on MacOS?

docs on all the methods in raw, especially where the params
differ from the C API

----------------

sqlite API issues:

should sqlite3_commit_hook() return something?  the C function returns the
user pointer, which has no useful parallel for us to return.  I sort of hate
the fact that it returns void, since we can't check errors on it.  but
the underlying C function doesn't really return any useful info for error
checking either.

unprotected sqlite3_value:  sqlite3_column_value, sqlite3_bind_value, sqlite3_result_value

sqlite3_create_module

sqlite3_db_config

sqlite3_db_filename
sqlite3_db_mutex
sqlite3_db_readonly

sqlite3_get_auxdata
sqlite3_set_auxdata

sqlite3_limit

sqlite3_progress_handler

sqlite3_randomness

sqlite3_soft_heap_limit64

sqlite3_wal_autocheckpoint
sqlite3_wal_checkpoint
sqlite3_wal_checkpoint_v2
sqlite3_wal_hook

sqlite3_busy_handler

sqlite3_collation_needed -- difficult because of the be handle passed
to the callback

sqlite3_config


