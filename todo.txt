
probably get rid of ns 1.1

handwritten pack.bat is fine.  but push.bat is ugly 
because all the nupkgs have the pre version timestamp
in the name.  wildcard?

generated nuspecs should contain relative paths

since we're introducing the e_sqlcipher name,
should we add 3 or 4 to distinguish the
underlying sqlcipher version?

the top half of the provider class is the
same for dynamic vs dllimport.  use a partial
class and share it?

new sn key for lib.e_sqlcipher.  hmmm.
should we just use the same one as before?
and why do we have the same key for 
the android and ios versions of this?
same goes for e_sqlite3.

--

runtimeconfig.dev.json
	AdditionalProbingingPath

LoadLibrary vs LoadLibraryEx

bundles:
	green
	e_sqlite3
	e_sqlcipher
	zetetic
	winsqlite3

figure out plats
	ios
	macos
	win
	android
	linux
	other?

in general, only one of the following is true:
	win, LoadLibrary, dll suffix
	everything else, dlopen
		macos, dylib suffix
		everything else, so suffix

Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().Location) -- netstandard 2.0
appdomain.currentdomain.basedirectory -- not in netcore
assembly.codebase -- netstandard 1.5
current working directory -- netstandard 1.3

ios: either system or internal

android: std places
	just load e_sqlite3?

.net core: should find from rid, just
load "e_sqlite3" ?

mono on mac
Xamarin.Mac
mono on linux
.net framework on windows
    subdirs from the targets file

cdecl vs stdcall?

maybe everything which needs a targets file should
also need to pass more info (a path) to Setup

--

add sqlite3_key et al to the pinvoke list?

have setup return the one that was used

string passed to LoadLibrary/dlopen
dlopen vs loadlib

constructing the string:
	basename
		e_sqlite3
		e_sqlcipher
		sqlite3
		sqlcipher
	add dll/dylib/so
	path
		starting
			cwd
			executingassembly.location
			other?
		subdir
			nothing?
			native/rid (targets)

perhaps just autogen a big list of permutations to try.
and then a loop that tries them.

use runtime platform info to reduce the size of the list.

or gen the list at runtime, using runtime platform info
to only gen the ones that make sense.  allows a custom
basename more easily.  gen_permutations_for().

--

run gen_build.cs under dotnet core

consider default enable_next_stmt() to false

review the weird stuff agg functions do
with the context pointer

in setup, check the current OS somehow so
that some checks (like LoadLibrary on non-Windows)
can be skipped.

default load, so the setup call can be optional
in many or most cases

maybe the Setup calls should return the sqlite
version et al?

chg release notes in nuspec to reference a URL

maybe don't do bundle_winsqlite3?  it's kind of
silly.  it doesn't actually bundle anything.  it
just calls (something like) Setup.Load_winsqlite3().

what is batteries_v2.sqlite3 for?

maybe batteries now are per-bundle.  one
function that figures out at runtime what
to load.  for green, it would need to check
to see if it's on iOS.

will bundle_green have a problem because
lib.e_sqlite3 is all one package?  so now
the e_sqlite3 build for iOS is included,
and we just have to have to require it not
to be used?

not sure we need bundle_green at all.

chg cb build scripts to use VS 2017, partly
so we can get arm64 on uwp

later: rename sqlcipher in cb to e_sqlcipher

test on uwp

restore those win32 set directory calls somewhere

preload from arch directory stuff.  subdirectory
by cpu arch.

--

deal with stdcall/winsqlite3 in Setup

need to setup some x86 stdcall builds for testing?
or just use winsqlite3 itself.  irritating that 
the test suite passes using winsqlite3 and either 
calling convention.  why?

DI for the utf8 stuff?  #202

more xunit test cases

goal is to have no ifdefs in core

chg to SourceGear name?

instead of delegate-ish types in raw.cs should the functions
take something like Func<whatever> ?


--

cb/bld

worry about Batteries_V2 bait and switch across
bundle types with project.json or new csproj, where
the "better" support for transitive dependencies
might break things.

in the readme, explain why iOS lib has static in name.
and why internal.  and why SQLitePCL.lib.embedded.Init()

need the ability to disconnect:
    1.  the env used to compile an assembly
    2.  the lib/env dir in nuget

for bundle_e_sqlite3, we want to build two things for netstandard11:
    1.  e_sqlite3, into netcoreapp
    2.  none, into netstandard11

enable_shared_cache.  is this present?  does akavache need it?

it's kinda wrong to always build batteries.cs with provider_none
for portable and netstandard.

is the v140 e_sqlite build compiled for app container only?

the batteries assemblies for wp80 don't need to
go in build, do they?

config_esqlite3 should get reworked, because it only
generates a nuspec, not a csproj.  in fact, it's just
a string toolset.

maybe the subdirs x86/x64 for loading with anycpu
should be the rid.  but this would break things,
so probably not.

several of the targets files are using the name
InjectReference when really they're just copying
the native DLL into the bin dir

change all the lib packages to put the binaries
in runtimes/rid/native, and change the .targets files
to use that path, and also change the targets files
to not do the copy when packages.config is present.

oren says kill the (equiv) platform builds and just use
netstandard.  and yes, keep NetStandard.Library in
the deps, even though it drags in tons of transitives.

understand runtime.json and rid-specific deps, even
if they are not officially supported

cppinterop is now the only assembly which has the
old name.  grumble.

problem with uwp test apps pfx file

problem with uwp test app, deploy, id ?

test runner for net45

rm cruft for old sqlcipher builds

in order to get back to netstandard for the tests,
we would need to switch xunit to the pre

--------

I wish the json generation code was using structures
instead of text writelines

how many cases are there where we could ditch a
platform-specific build and just let it use
netstandard?  but then NetStandard.Library gets
dragged in, which is a lot of weird stuff.

problem with current testapps sln is that the
framework used to resolve is predetermined.
it would be better to gen the projects from
scratch and somehow add the nuget packages.
problem is specific to packages.config?

consider creating a new build directory on
every build

why does the error msg say ios project.json needs runtimes : win ?

is CopyNuGetImplementations causing trouble?
with project.json : runtimes?

ios build machine needs sdk 9.3

should MonoAndroid version be 2.3 or 6.0 ?

general-purpose gen_nuspec function

combine net45 libs into one pkg?

do we need a copy of the main raw assembly compiled specifically
for every tfm?  like android?  or is it sufficient to have
it compiled for each set of compile options, and each platform
use the one that is compatible with it.  problem with netstandard
is that it brings in lots of little deps.

need to go to nuget.org and mark some of the older 
packages deprecated

maybe the "first pinvoke set that works" code should
go somewhere else, higher up?

currently wp8-SL support is limited to e_sqlite3.  no
sqlcipher.  no extension SDK.  although we could in
theory build multiple versions of this, each linked
against a different library name.

--------

can we do a dylib ios version?

version numbers on SQLitePCL.custom stuff should
not need to match SQLitePCL.raw, and might want to
match the underlying SQLite version number.

does the native code stuff in nuget 3.x get this
specific?  can we provide a package which just looks
at the environment and then has a dependency on
The Right One?

xamarin.mac shouldn't even need to be built on the Mac.
just use a compatible build of SQLitePCL.raw.dll

----

clean out the rest of this file

----

Do the collation hook fix thing for config_log

consider whether maybe the sqlite3 intptr dispose should check
the version number and call sqlite3_close_v2 when it's supposedly
available.

add visual studio 2013 c++ runtime sdkreference.  but injecting an
SDKReference in the .targets file sort of doesn't work, and using
a powershell tool is so inelegant.  MESSAGE.

annoying that an injected reference doesn't show up in the
References list in visual studio

error if configuration is not release or debug
but configuration in xamarin.ios is actually stuff like iPhone, etc

why does the sqlitepcl ios platform assembly show
no assembly info when viewed in xamarin studio?

Win32 in the sln file

auto-generate the test projects as well?

docs: need a complete list, in tabular form, of the platform
assemblies and an explanation of the use cases for each one.
auto-generate this.

need at least one test project for each platform assembly.  

add an NUnit project on Windows/Net45, so that build breakage
with NUnit can be detected when making changes on windows.
should reference NUnit as a nuget package

sqlite3.Mac?  or use platform-installed sqlite on MacOS?

docs on all the methods in raw, especially where the params
differ from the C API

----------------

sqlite API issues:

should sqlite3_commit_hook() return something?  the C function returns the
user pointer, which has no useful parallel for us to return.  I sort of hate
the fact that it returns void, since we can't check errors on it.  but
the underlying C function doesn't really return any useful info for error
checking either.

unprotected sqlite3_value:  sqlite3_column_value, sqlite3_bind_value, sqlite3_result_value

sqlite3_create_module

sqlite3_db_config

sqlite3_db_mutex

sqlite3_get_auxdata
sqlite3_set_auxdata

sqlite3_limit

sqlite3_progress_handler

sqlite3_randomness

sqlite3_soft_heap_limit64

sqlite3_wal_autocheckpoint
sqlite3_wal_checkpoint
sqlite3_wal_checkpoint_v2
sqlite3_wal_hook

sqlite3_busy_handler

sqlite3_collation_needed -- difficult because of the be handle passed
to the callback

