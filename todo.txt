
why is impl callbacks a separate nuget package?

how long has the mac sqlcipher dylib build been broken?

ios sqlcipher build will need the stub for
sqlite3_win32_set_directory.  ouch, except
the zetetic build won't have that.  might
need to just do the ifdef.

android: 70 pass, 2 fail
    create_table_file
    wal

xDelete fails on UWP

can ios use provider dynamic with null for
the dlopen argument?  seems like I tried this
and it didn't work, but I don't remember for sure.

how to pass null to the tail for sqlite3_prepare_?

need a test that actually uses the prepare flags
for sqlite3_prepare_v3, like persistent

restore those win32 set directory calls somewhere.
but we don't want ifdef down in raw or provider.
maybe in batteries?  problem is they prevent a
sqlite3_config() call.

		NativeMethods.sqlite3_win32_set_directory(/*data directory type*/1, Windows.Storage.ApplicationData.Current.LocalFolder.Path);
		NativeMethods.sqlite3_win32_set_directory(/*temp directory type*/2, Windows.Storage.ApplicationData.Current.TemporaryFolder.Path);

finish impl of batteries for the net461 case,
like the previous preload from arch dir.

net461 or net472 ?

investigate console UWP apps with C# for testing.
build 17134.

chg release notes in nuspec to reference a URL?
on github?  on my blog?

test on uwp, ios, android, net461, mono

--

lots of places in the sqlite API give a pointer to
a zero-terminated string, which would require a
strlen-ish thing to convert to a span.  how many
of these should just return ReadOnlySpan<byte> ?

when using a span for a zero-terminated string,
does the span length include the zero?  if we are
converting to a string, we don't want the zero.
actually we never want the zero to be considered
part of the string.  but for sqlite apis that expect
it to be there, we have to add one.  and that happens
in to_utf8() alloc the byte array.  which means when
that ba gets auto-cast to ReadOnlySpan<byte>, the
length will include the zero.  so whenever we use the
Length, we might need to check and see whether we
need to strip the zero or not.

if span has the zero byte, then we basically have two
ways of determining the length of the string, and
we therefore might want to verify that they agree.

we might want to always include the zero byte in the
length when passing strings back up, for consistency
with the cases where we pass a string down, but that 
seems silly, since it means the length is wrong.

if we don't use or verify the length on a span passed
down, then the length is just ignored.

it would be wrong to pass down a string which has a
zero terminator but not include that zero in the span
length.  the zero is an expected part of the data
sqlite wants.

it would nice if span-with-z and span-without-z could
be different types, so the compiler could tell us when
we pass the wrong one.

for strings that come back from sqlite, maybe it's just 
better to leave things as they are, returning only
the pointer, and leaving it up to from_utf8 to do
the strlen.  but then why did we change all the downward
cases to a span, when they have the same problem?  because
all those cases need a pin, and we wanted the pin to
happen inside the provider.

we're gonna need functions that (1) make sure the zero
terminator is the last byte in a span, and (2) make sure
the last byte in a span is NOT a zero.

--

investigate GC.AddMemoryPressure()

might want bind_blob to allow specifying something
other than transient.  current implementation makes
a copy of the blob every time.

in the raw layer, how to distinguish things that
return a string vs things that return a utf8
byte span?  C# doesn't do overloads on return type.

should we wrap/alias ReadOnlySpan<byte> to something
like utf8string ?  is that what the new Utf8String
type is?

investigate new utf8 things in System.Memory pkg

multi-target to avoid dep on System.Memory for netcore2.1+ ?

need some tests for sqlite-ish case insensitivity of
collation names

--

revisit passing 'object' as user data round trip
through a callback

--

instead of just IGetFunctionPointer, should
we have IResolveLibrary?  how should we wrap the
Load part of NativeLibrary?  or maybe the resulting
IGetFunctionPointer is all that matters, since that's
all provider.dynamic needs?

but who owns the dll handle, and therefore has the
obligation to free it?

figure out SQLitePCLRaw.resolver.whatever.
it's platform-specific.  except for dotnet core 3,
which has NativeLibrary, which we can wrap.

name.  resolver?  resolver.dotnetcore3?

explore bundle native code in embedded resource,
extract to known location and use provider dynamic.
would allow builds to be done entirely without
xamarin sdks.  but the location to write the dll
would need to be injected from platform code?

to be even more ridiculous, we could bundle the
native code in C# as a binary array.  :-)  at
least then we would eliminate all involvement
from msbuild.

problem with embed is that it won't work for all
platforms, still prefer runtimes folder for .net core.  
which means we need two copies?  

use embed for ios and android, like now?  but
for ios, better than static.  and both avoid the
need for platform-specific build sdk stuff?

or maybe just emulate the runtimes folder on all
platforms?  ios and android included?

hmph.  xam android says normal content item is
not supported.  and xam ios also.

but does plain embedded resource work on both
android and ios?

might need to go back to separating the nuget
packages for e_sqlite3 and e_sqlcipher by
platform?  still don't need v120 and v110 and
so on.  but maybe windows, mac, linux separate
again.  but ms ships libuv with all platforms
in one package...

resolver should probably check File.Exists
(on things that are an absolute path) before trying
LoadLibrary/dlopen.

zetetic dynamic needs to look in dirs named x86/x64, 
not rids.  for compat with their existing package.
chg Setup.Load() to check the x86 and x64 dirs?
or create a special Load call for that case?

--

gen_nuspec should write the same EOL convention
on all platforms.  using XmlWriterSettings. NewLineChars
doesn't seem to do what it should.  actually, that
seems fine.  now the problem is the slash-vs-backslash
issue in the nuspec paths.

whether in embedded resource or just a content
file, test using the dylib for ios.  or perhaps not.

review EntryPoint attribute

fix build script to do clean

NuspecProperties doesn't work for PackageTags
because of the semicolon inside it.  how to escape
that?

need to fix up name of sqlcipher lib for android.
needs e_ prefix.

use new t4 local cli tool package
    PlatformNotSupportedException
    logged, mono/t4 #42, fix pending

need push script.  reads the xml file to get
the version

.editorconfig

dotnet-format.  but won't work for provider.tt.

should the other batteries also build on a placeholder
instead of the actual ios lib assembly?  allows
dotnet cli instead of desktop msbuild.

want a way to force the tests at the end of
build.bat to use the nupkgs just built, not the
ones in the nuget cache.  previous workaround
was to force a timestamp into the pkg name, but
that's sad.

with an SDK-style net461 project, how to control
the cpu target of the build?  msbuild prop Platform?

I wonder if there are any other ways that v2 breaks 
the existing zetetic package.

nuspec should show SQLitePCLRaw org account as
owner?

what should the nuspecs say for min client version?
nuspecs generated by dotnet pack do not have this,
but this was apparently a bug that has been fixed.

DONE: consider default enable_next_stmt() to false

why is the device xunit runner for UWP crashing?

msbuild props to omit native builds in targets?

concern about dictionary<intptr, T> because it's
a value type?  ios AOT.  ToString() instead?
it would seem that the latest versions of mono
now support this case.

DONE: maybe v2 should use the v141 builds and include arm64

nuspec tags.  write them into Directory.Build.props from
gen_nuspecs?

consider build the tests as an assembly instead of always
compiling the file

--

since we're introducing the e_sqlcipher name,
should we add 3 or 4 to distinguish the
underlying sqlcipher version?

the top half of the provider class is the
same for dynamic vs dllimport.  use a partial
class and share it?

new sn key for lib.e_sqlcipher.  hmmm.
or should we just use the same one as before?
and why do we have the same key for 
the android and ios versions of this?
same goes for e_sqlite3.

--

in general, only one of the following is true:
	win, LoadLibrary, dll suffix
	everything else, dlopen
		macos, dylib suffix
		everything else, so suffix

ios: either system or internal

android: std places
	just load e_sqlite3?

.net core: should find from rid, just
load "e_sqlite3" ?

mono on mac
Xamarin.Mac
mono on linux
.net framework on windows
    subdirs from the targets file

cdecl vs stdcall?

maybe everything which needs a targets file should
also need to pass more info (a path) to Setup

--

add sqlite3_key et al to the pinvoke list?

constructing the string:
	basename
		e_sqlite3
		e_sqlcipher
		sqlite3
		sqlcipher
	add dll/dylib/so suffix
	path
		starting
			cwd
			executingassembly.location
			other?
		subdir
			nothing?
			native/rid (targets)

--

review the weird stuff agg functions do
with the context pointer

later: rename sqlcipher in cb to e_sqlcipher

--

need to setup some x86 stdcall builds for testing?
or just use winsqlite3 itself.  irritating that 
the test suite passes using winsqlite3 and either 
calling convention.  why?

more xunit test cases

goal is to have no ifdefs in core

--

in the readme, explain why iOS lib has static in name.
and why internal.  and why SQLitePCL.lib.embedded.Init()

need the ability to disconnect:
    1.  the env used to compile an assembly
    2.  the lib/env dir in nuget

for bundle_e_sqlite3, we want to build two things for netstandard11:
    1.  e_sqlite3, into netcoreapp
    2.  none, into netstandard11

enable_shared_cache.  is this present?  does akavache need it?

change the targets files
to not do the copy when packages.config is present?

understand runtime.json and rid-specific deps, even
if they are not officially supported

--------

is CopyNuGetImplementations causing trouble?
with project.json : runtimes?

need to go to nuget.org and mark some of the older 
packages deprecated

maybe the "first pinvoke set that works" code should
go somewhere else, higher up?

--------

can we do a dylib ios version?

----

docs on all the methods in raw, especially where the params
differ from the C API

----------------

sqlite API issues:

should sqlite3_commit_hook() return something?  the C function returns the
user pointer, which has no useful parallel for us to return.  I sort of hate
the fact that it returns void, since we can't check errors on it.  but
the underlying C function doesn't really return any useful info for error
checking either.

should maybe use the value from commit_hook (and rollback_hook) internally
to verify/dispose the hook_handle?

unprotected sqlite3_value:  sqlite3_column_value, sqlite3_bind_value, sqlite3_result_value

sqlite3_create_module

sqlite3_db_config

sqlite3_db_mutex

sqlite3_get_auxdata
sqlite3_set_auxdata

sqlite3_limit

sqlite3_randomness

sqlite3_soft_heap_limit64

sqlite3_wal_autocheckpoint
sqlite3_wal_checkpoint
sqlite3_wal_checkpoint_v2
sqlite3_wal_hook

sqlite3_busy_handler

sqlite3_collation_needed -- difficult because of the be handle passed
to the callback

